Version 1
SubGoalCombiner SGC_AND
INITSECTION
DB_PPMeter_TurnStartedTimerPrefix("PPMeterTurnStartedTimer_");
DB_PPMeter_DamageDoneTimerPrefix("PPMeterDamageDoneTimer_");
DB_PPMeter_IsLongCombatTimerPrefix("PPMeterIsLongCombatTimer_");
DB_PPMeter_AfterLongCombatDelayPrefix("PPMeterAfterLongCombatDelayTimer_");
DB_PPMeter_DataWriteDelayMs(250);
DB_PPMeter_LongCombatMinimumLengthMs(500);
DB_PPMeter_LongCombatAfterCombatDelay(250);

// DB_PPMeter_TempDamage((CHARACTER)_Character, (REAL)_Damage, (STRING)_TimerStr);
// DB_PPMeter_LongCombatCandidate((GUIDSTRING)_CombatGuid, (STRING)_TimerStr);
// DB_PPMeter_LongCombat((GUIDSTRING)_CombatGuid);
KBSECTION
// Process CombatStarted, CombatEnded - fill DB_PPMeter_LongCombat
//REGION
IF
CombatStarted(_CombatGuid)
AND
DB_PPMeter_IsLongCombatTimerPrefix(_Prefix)
AND
ConcatenateGUID(_Prefix, _CombatGuid, _TimerString)
THEN
PROC_PPMeter_ProcessCombatStartedInner(_CombatGuid, _TimerString);

PROC
PROC_PPMeter_ProcessCombatStartedInner((GUIDSTRING)_CombatGuid, (STRING)_TimerStr)
THEN
DB_PPMeter_LongCombatCandidate(_CombatGuid, _TimerStr);
DebugLog("PPMLog: DB_PPMeter_LongCombatCandidate added");

PROC
PROC_PPMeter_ProcessCombatStartedInner((GUIDSTRING)_CombatGuid, (STRING)_TimerStr)
AND
DB_PPMeter_LongCombatMinimumLengthMs(_Delay)
THEN
TimerLaunch(_TimerStr, _Delay);
DebugLog("PPMLog: Combat Minimum Length timer started");

IF
CombatEnded(_CombatGuid)
AND
DB_PPMeter_LongCombatCandidate(_CombatGuid, _TimerStr)
AND
TimerExists(_TimerStr, 1)  // if timer still ticking
THEN
TimerCancel(_TimerStr);
NOT DB_PPMeter_LongCombatCandidate(_CombatGuid, _TimerStr);
DebugLog("PPMLog: Combat was short");

IF
TimerFinished(_TimerStr)
AND
DB_PPMeter_LongCombatCandidate(_CombatGuid, _TimerStr)  // if Timer Strings match
THEN
DB_PPMeter_LongCombat(_CombatGuid);
NOT DB_PPMeter_LongCombatCandidate(_CombatGuid, _TimerStr);
DebugLog("PPMLog: Combat is long!");



// Remove DB_PPMeter_LongCombat after configured delay
IF
CombatEnded(_CombatGuid)
AND
DB_PPMeter_LongCombat(_CombatGuid)
AND
DB_PPMeter_LongCombatAfterCombatDelay(_Delay)
AND
DB_PPMeter_AfterLongCombatDelayPrefix(_Prefix)
AND
ConcatenateGUID(_Prefix, _CombatGuid, _TimerStr)
THEN
TimerLaunch(_TimerStr, _Delay);
DebugLog("PPMLog: Long combat ended, scheduled deletion timer");

IF
TimerFinished(_TimerStr)
AND
DB_PPMeter_LongCombat(_CombatGuid)
AND
GUIDToString(_CombatGuid, _CombatGUIDStr)
AND
IsSubstring(_TimerStr, _CombatGUIDStr, 1)
THEN
NOT DB_PPMeter_LongCombat(_CombatGuid);
DebugLog("PPMLog: Long combat removed after delay");
//END_REGION


//REGION // handle TurnStarted - count rounds
IF
TurnStarted((CHARACTER)_Character)
AND
DB_PPMeter_TurnStartedTimerPrefix(_Prefix)
AND
ConcatenateGUID(_Prefix, _Character, _TimerStr)
AND
DB_PPMeter_DataWriteDelayMs(_Delay)
THEN
RealtimeObjectTimerLaunch(_Character, _TimerStr, _Delay);

IF
ObjectTimerFinished((CHARACTER)_Character, _TimerStr)
AND
IsInCombat(_Character, 1)  // rounds++ only if entity is still in combat
AND
DB_PPMeter_TurnStartedTimerPrefix(_Prefix)
AND
ConcatenateGUID(_Prefix, _Character, _TimerStr)  // if strings match
THEN
PROC_PPMeter_ProcessTurnStartedWithDelay(_Character);

PROC
PROC_PPMeter_ProcessTurnStartedWithDelay((CHARACTER)_Character)
AND
DB_PartyMembers(_Character)
AND
DB_PPMeter_Lifetime(_Lifetime)
THEN
PROC_PPMeterAdd(_Character, _Lifetime, "RoundsCount", 1.0);
//END_REGION


//REGION // handle AttackedBy - count damage dealt
IF
AttackedBy((GUIDSTRING)_Defender, (CHARACTER)_AttackerOwner, (GUIDSTRING)_Attacker, (STRING)_DamageType, (INTEGER)_DamageAmount, (STRING)_DamageCause, (INTEGER)_StoryActionID)
AND
DB_PartyMembers(_AttackerOwner)
AND
_DamageAmount > 0.0
AND
IsEnemy(_AttackerOwner, (CHARACTER)_Defender, 1)
AND
IntegerToReal(_DamageAmount, _DamageAmountReal)
AND
DB_PPMeter_DamageDoneTimerPrefix(_Prefix)
AND
DB_PPMeter_DataWriteDelayMs(_Delay)
AND
ConcatenateGUID(_Prefix, _AttackerOwner, _TimerStr1)
AND
ConcatenateInteger(_TimerStr1, _StoryActionID, _TimerStr)
THEN
DB_PPMeter_TempDamage(_AttackerOwner, _DamageAmountReal, _TimerStr);
RealtimeObjectTimerLaunch(_AttackerOwner, _TimerStr, _Delay);

IF
ObjectTimerFinished((CHARACTER)_Character, _TimerStr)
AND
IsInCombat(_Character, 1)  // count damage only if entity is still in combat
AND
DB_PPMeter_TempDamage(_Character, _Damage, _TimerStr)
THEN
PROC_PPMeter_ProcessAddDamage(_Character, _Damage);

// Clear DB record after processed timer
IF
ObjectTimerFinished((CHARACTER)_Character, _TimerStr)
AND
DB_PPMeter_TempDamage(_Character, _Damage, _TimerStr)
THEN
NOT DB_PPMeter_TempDamage(_Character, _Damage, _TimerStr);

PROC
PROC_PPMeter_ProcessAddDamage((CHARACTER)_Character, (REAL)_Damage)
AND
DB_PPMeter_Lifetime(_Lifetime)  // Apply damage to every lifetime
THEN
PROC_PPMeterAdd(_Character, _Lifetime, "Damage", _Damage);
//END_REGION


//REGION // handle AttackedBy - count damage taken
IF
AttackedBy((GUIDSTRING)_Defender, (CHARACTER)_AttackerOwner, (GUIDSTRING)_Attacker, (STRING)_DamageType, (INTEGER)_DamageAmount, (STRING)_DamageCause, (INTEGER)_StoryActionID)
AND
DB_PartyMembers((CHARACTER)_Defender)
AND
_DamageAmount > 0.0
AND
IsEnemy((CHARACTER)_Defender, _AttackerOwner, 1)
AND
DB_PPMeter_Lifetime(_Lifetime)  // Apply damage taken to every lifetime
AND
IntegerToReal(_DamageAmount, _DamageAmountReal)
THEN
PROC_PPMeterAdd((CHARACTER)_Defender, _Lifetime, "DamageTaken", _DamageAmountReal);
//END_REGION
EXITSECTION

ENDEXITSECTION
ParentTargetEdge "Start"
